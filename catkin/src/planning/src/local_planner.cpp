/*
* local_planner
* A node that will use waypoints from a path generated by global_planner to navigate.
*	-May also use costmap_2d to do a small amount of obstacle avoidance if time-permitting!
*
*	Luc A. Bettaieb
* 	bettaieb@case.edu
*
*	12.15.14
*/

#include <planning/local_planner.h>

/*----------Fields----------*/
ros::Subscriber sub_odom_; //Subscribe to the odometry of the robot for perfect localization
ros::Subscriber sub_path_; //Subscribe to the path generated by global_planner
ros::Publisher pub_vel_;

nav_msgs::Path path_;
nav_msgs::Odometry odom_;
geometry_msgs::Twist vel;

bool hasPath = false;
bool goalReached = false;

/*----------Functions----------*/
void pathCB(const nav_msgs::Path &path){
	//ROS_INFO("got path.");
	path_ = path;
	hasPath = true;
}
void odomCB(const nav_msgs::Odometry &odom){
	//ROS_INFO("got new odom.");
	odom_ = odom;
}
float getAngleFromQuaternion(geometry_msgs::Quaternion q){
	return atan2(2*q.y*q.w-2*q.x*q.z , 1 - pow(2*q.y,2) - pow(2*q.z,2));

}

void navigateToSubgoal(geometry_msgs::Pose &subgoal){
	ROS_INFO("We be navigatin'.");
	std::cout << "" << (tf::getYaw(odom_.pose.pose.orientation) - tf::getYaw(subgoal.orientation)) <<std::endl;
	//(tf::getYaw(odom_.pose.pose.orientation) - tf::getYaw(subgoal.orientation)  > .1)

	while( getAngleFromQuaternion(odom_.pose.pose.orientation) - getAngleFromQuaternion(subgoal.orientation) > 0.1  ){
		ros::spinOnce();

		//(((1/M_PI)*(2*acos(odom_.pose.pose.orientation.w))) - ((1/M_PI)*(2*acos(subgoal.orientation.w)))) > .1
		ROS_INFO("ANGLE GO");
		//std::cout << "delta angle? " << ((1/M_PI)*(2*acos(odom_.pose.pose.orientation.w))) - ((1/M_PI)*(2*acos(subgoal.orientation.w))) << std::endl;
		
		vel.angular.z = 3 * atan2(subgoal.position.y - odom_.pose.pose.position.y, subgoal.position.x - odom_.pose.pose.position.x);
		
		pub_vel_.publish(vel);
	}
	
	vel.angular.z = 0;
	while(! ((odom_.pose.pose.position.x < subgoal.position.x + .05) && (odom_.pose.pose.position.x > subgoal.position.x - 0.5)) ) { //&& (odom_.pose.pose.position.y == subgoal.position.y))
		ros::spinOnce();
		//ROS_INFO("TRANS GO");

		
		//std::cout << "ang: " <<((1/M_PI)*(2*acos(odom_.pose.pose.orientation.w))) << std::endl;
		//send a linear velocity proportional to the distance 
		vel.linear.x = .4 * sqrt(pow(subgoal.position.x - odom_.pose.pose.position.x, 2)+pow(subgoal.position.y - odom_.pose.pose.position.y, 2));

		pub_vel_.publish(vel);
	}
}

/*----------Main----------*/
int main(int argc, char** argv){
	ros::init(argc, argv, "local_planner");
	ros::NodeHandle nh;

	sub_path_ = nh.subscribe("/path", 10, pathCB);
	sub_odom_ = nh.subscribe("/robot0/odom", 10, odomCB);

	pub_vel_ = nh.advertise<geometry_msgs::Twist>("/robot0/cmd_vel", 1);

	geometry_msgs::Pose subgoal;

	while(ros::ok() && !goalReached){
		if(hasPath){
			for(int i = 0; i < path_.poses.size(); i++){
				ros::spinOnce();
				vel.linear.x = 0;
				vel.angular.z = 0;
				
				subgoal = path_.poses.at(i).pose;
				ROS_INFO("!!!!!!!!!!!!~~~~~_~new pose");
				//std::cout << path_.poses.at(i).pose.position.x <<std::endl;
				navigateToSubgoal(subgoal);
					//do nothing?
			}
		}


		ros::spinOnce();
	}

	
	ros::spin();
	return 0;
}